- [作业9](#作业9)
  - [1. 搭建主多从数据库集群](#1-搭建主多从数据库集群)
    - [1.1 主库配置](#11-主库配置)
    - [1.2 从库配置](#12-从库配置)
    - [1.3 验证操作](#13-验证操作)
  - [2. 实现读写分离](#2-实现读写分离)
    - [2.1 编写application.yml](#21-编写applicationyml)
    - [2.2 配置多数据源](#22-配置多数据源)
    - [2.3 编写 DbContextHolder 类](#23-编写-dbcontextholder-类)
    - [2.4 获取key](#24-获取key)
    - [2.5 选择数据源](#25-选择数据源)
    - [2.6 测试](#26-测试)
- [参考](#参考)
# 作业9

**题目描述**：读写分离 - 动态切换数据源版本 1.0。

* 基于 Spring/Spring Boot，配置多个数据源（例如2个，master 和 slave）。
* 根据具体的 Service 方法是否会操作数据，注入不同的数据源，1.0版本。
* 改进1.1：基于操作 AbstractRoutingDataSource 和自定义注解 readOnly 之类的，简化自动切换数据源。
* 改进1.2：支持配置多个从库。
* 改进1.3：支持多个从库的负载均衡。

------

> 代码 —— [Misson09](https://github.com/zgkaii/java-homework/tree/main/week07-mysql/src/main/java/com/zgkaii/mysql/mission09)

## 1. 搭建主多从数据库集群

### 1.1 主库配置

my-default.ini配置如下：

```ini
basedir = ../
datadir = ../data
port = 3316
server_id = 1

default_authentication_plugin=mysql_native_password
sql-mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO
log_bin=mysql-bin
binlog-format=Row
```

初始化数据库：`mysqld --defaults-file=my-default.ini --initialize-insecure`

启动数据库：`start mysqld`

登录主节点：`mysql -uroot -hlocalhost -P3316`

```mysql
mysql> CREATE USER 'repl'@'%' IDENTIFIED BY '123456'; # 创建用户

mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%'; # 分配权限

mysql> flush privileges; # 刷新权限
```

使用`show master status;`语句查看主库状态：

```mysql
mysql> show master status;
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000002 |     1429 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
```

### 1.2 从库配置

my-default.ini配置如下：

```ini
basedir = ../
datadir = ../data2
port = 3326
server_id = 2

default_authentication_plugin=mysql_native_password
sql-mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO
log_bin=mysql-bin
binlog-format=Row
```

初始化数据库：`mysqld --defaults-file=my-default.ini --initialize-insecure`

启动数据库：`start mysqld`

登录从节点：`mysql -uroot -hlocalhost -P3326`

连接主库：

```mysql
CHANGE MASTER TO
    MASTER_HOST='localhost',  
    MASTER_PORT = 3316,
    MASTER_USER='repl',      
    MASTER_PASSWORD='123456',   
    MASTER_LOG_FILE='mysql-bin.000002',
    MASTER_LOG_POS=1459;
```

启动slave：`start slave;`

查看状态：`show slave status\G `

```mysql
mysql> show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: localhost
                  Master_User: repl
                  Master_Port: 3316
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000002
          Read_Master_Log_Pos: 3279
               Relay_Log_File: LAPTOP-BTULSLNT-relay-bin.000002
                Relay_Log_Pos: 2140
        Relay_Master_Log_File: mysql-bin.000002
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
              ------ omit ------
```

默认情况下备份是主库的全部操作都会备份到从库，实际可能需要忽略某些库，可以在主库中增加如下配置：

```ini
# 不同步哪些数据库
binlog-ignore-db = mysql
binlog-ignore-db = information_schema

# 只同步哪些数据库
binlog-do-db = db
```

### 1.3 验证操作

主库中操作：

```mysql
mysql> use db;
Database changed
mysql> create table student(id int(10),name varchar(20));
Query OK, 0 rows affected (0.17 sec)
mysql> insert into student(id,name) values(1,'zhangsan');
Query OK, 1 rows affected (0.04 sec)
```

查看从库：

```mysql
mysql> show tables;
+--------------+
| Tables_in_db |
+--------------+
| student      |
+--------------+
2 rows in set (0.00 sec)

mysql> select * from student;
+------+----------+
| id   | name     |
+------+----------+
|    1 | zhangsan |
+------+----------+
1 row in set (0.00 sec)
```

## 2. 实现读写分离

使用AbstractRoutingDataSource，基于特定的查询key路由到特定的数据源。建立多个 datasource 放到 TargetDataSource 中，同时重写 dertermineCurrentLookupKey 方法来决定使用哪个 key。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210514132954634.png" width="400px"/>
</div>

### 2.1 编写application.yml

```yml
mysql:
  datasource:
    #读库数目
    num: 1
    type-aliases-package: com.zgkaii.mysql.mission09.entity
    mapper-locations: classpath:/mapper/*.xml
    config-location: classpath:/mybatis-config.xml
    write:
      url: jdbc:mysql://localhost:3316/db?useUnicode=true&characterEncoding=utf8&allowMultiQueries=true
      username: root
      password: 513701
      driver-class-name: com.mysql.cj.jdbc.Driver
    read:
      url: jdbc:mysql://localhost:3326/db?useUnicode=true&characterEncoding=utf8&allowMultiQueries=true
      username: root
      password: 513701
      driver-class-name: com.mysql.cj.jdbc.Driver
```

### 2.2 配置多数据源

这里，我们配置了3个数据源，1个read，1个wirte，1个路由数据源。前2个数据源都是为了生成第3个数据源，而且后续我们只用这最后一个路由数据源。

同时，需要为事务管理器和MyBatis手动指定一个明确的数据源。

```java
@Configuration
@MapperScan(basePackages = "com.zgkaii.mysql.mission09.mapper", sqlSessionFactoryRef = "sqlSessionFactory")
public class DataSourceConfig {

    @Value("${mysql.datasource.mapper-locations}")
    private String mapperLocation;

    @Value("${mysql.datasource.config-location}")
    private String configLocation;

    /**
     * 写数据源
     *
     * @Primary 标志这个 Bean 如果在多个同类 Bean 候选时，该 Bean 优先被考虑。
     * 多数据源配置的时候注意，必须要有一个主数据源，用 @Primary 标志该 Bean。
     */
    @Primary
    @Bean
    @ConfigurationProperties(prefix = "mysql.datasource.write")
    public DataSource writeDataSource() {
        return new DruidDataSource();
    }

    /**
     * 读数据源
     */
    @Bean
    @ConfigurationProperties(prefix = "mysql.datasource.read")
    public DataSource read1() {
        return new DruidDataSource();
    }

    /**
     * 3个数据源 一个write、一个read、一个路由数据源，后续只用到路由数据源
     */
    @Bean
    public AbstractRoutingDataSource routingDataSource() {
        MyAbstractRoutingDataSource myRoutingDataSource = new MyAbstractRoutingDataSource();
        HashMap<Object, Object> targetDataSources = new HashMap<>(2);
        targetDataSources.put(DbContextHolder.WRITE, writeDataSource());
        targetDataSources.put(DbContextHolder.READ + "1", read1());
        // 后续可以再加从库
        myRoutingDataSource.setDefaultTargetDataSource(writeDataSource());
        myRoutingDataSource.setTargetDataSources(targetDataSources);
        return myRoutingDataSource;
    }

    /**
     * 为SqlSessionFactory指定数据源
     */
    @Bean
    public SqlSessionFactory sqlSessionFactory() throws Exception {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(routingDataSource());
        ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        // mybatis的xml的配置
        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(mapperLocation));
        sqlSessionFactoryBean.setConfigLocation(resolver.getResource(configLocation));
        return sqlSessionFactoryBean.getObject();
    }

    /**
     * 为事务管理器制定数据源
     */
    @Bean
    public DataSourceTransactionManager dataSourceTransactionManager() {
        return new DataSourceTransactionManager(routingDataSource());
    }
}
```

### 2.3 编写 DbContextHolder 类

通过ThreadLocal将数据源设置到每个线程上下文中，利用ThreadLocal保存当前线程是否处于读模式（通过开始READ_ONLY注解在开始操作前设置模式为读模式，操作结束后清除该数据，避免内存泄漏，同时也为了后续在该线程进行写操作时任然为读模式。

```java
public class DbContextHolder {

    private static Logger log = LoggerFactory.getLogger(DbContextHolder.class);
    public static final String WRITE = "write";
    public static final String READ = "read";

    private static ThreadLocal<String> contextHolder = new ThreadLocal<>();

    public static void setDbType(String dbType) {
        if (dbType == null) {
            log.error("dbType为空");
            throw new NullPointerException();
        }
        log.info("设置dbType为：{}", dbType);
        contextHolder.set(dbType);
    }

    public static String getDbType() {
        return contextHolder.get() == null ? WRITE : contextHolder.get();
    }

    public static void clearDbType() {
        contextHolder.remove();
    }
}
```

### 2.4 获取key

Spring 在开始进行数据库操作时会通过`determineCurrentLookupKey()`方法来决定使用哪个数据库，因此我们在这里调用上面 DbContextHolder 类的`getDbType()`方法获取当前操作类别，同时可进行读库的负载均衡。

```java
public class MyAbstractRoutingDataSource extends AbstractRoutingDataSource {
    @Value("${mysql.datasource.num}")
    private int num;

    private final Logger log = LoggerFactory.getLogger(this.getClass());

    @Override
    protected Object determineCurrentLookupKey() {
        String typeKey = DbContextHolder.getDbType();
        if (typeKey == DbContextHolder.WRITE) {
            log.info("===> 使用了主库");
            return typeKey;
        }
        // 使用随机数决定使用哪个读库
        int sum = getRandom(1, num);
        log.info("===> 使用了读库{}", sum);
        return DbContextHolder.READ + sum;
    }

    private static int getRandom(int min, int max) {
        return (int) Math.floor(Math.random() * (max - min + 1)) + min;
    }
}
```

### 2.5 选择数据源

多数据源配置好了，但是代码层面如何选择选择数据源呢？这里选择注解的方式。

首先定义一个只读注解，被这个注解方法使用读库，其他使用写库，如果项目是中途改造成读写分离可使用这个方法，无需修改业务代码，只要在只读的 service 方法上加一个注解即可。

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ReadOnly {
}
```

然后写一个切面来切换数据使用哪种数据源，重写 getOrder 保证本切面优先级高于事务切面优先级。

```java
@Aspect
@Component
public class ReadOnlyInterceptor implements Ordered {
    private static final Logger log = LoggerFactory.getLogger(ReadOnlyInterceptor.class);

    @Around("@annotation(readOnly)")
    public Object setRead(ProceedingJoinPoint joinPoint, ReadOnly readOnly) throws Throwable {
        try {
            DbContextHolder.setDbType(DbContextHolder.READ);
            return joinPoint.proceed();
        } finally {
            DbContextHolder.clearDbType();
            log.info("清除ThreadLocal");
        }
    }

    /**
     * getOrder 保证本切面优先级高于事务切面优先级
     */
    @Override
    public int getOrder() {
        return 0;
    }
}
```

### 2.6 测试

编写测试方法：

```java
    @Test
    public void writeAndRead() {
        Student student = new Student();
        student.setId(4);
        student.setName("mazi");
        studentService.insert(student);
        List<Student> studentList = studentService.query();
        System.out.println("===> 读取数据");
        System.out.println(studentList.toString());
    }
```

测试前主从库数据：

```mysql
mysql> select * from student; #主库
+------+----------+
| id   | name     |
+------+----------+
|    1 | zhangsan |
|    2 | lisi     |
|    3 | wangwu   |
+------+----------+

mysql> select * from student; #从库，这里刻意删除了id = 3的数据
+------+----------+
| id   | name     |
+------+----------+
|    1 | zhangsan |
|    2 | lisi     |
|    3 | wangwu   |
+------+----------+
```

运行`writeAndRead()`方法：、

```java
2021-05-14 22:32:57.986  INFO 6324 --- [main] c.z.m.m.c.MyAbstractRoutingDataSource    : ===> 使用了主库
2021-05-14 22:32:58.079  INFO 6324 --- [main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} inited
2021-05-14 22:32:58.296  INFO 6324 --- [main] c.z.m.mission09.config.DbContextHolder   : 设置dbType为：read
2021-05-14 22:32:58.300  INFO 6324 --- [main] c.z.m.m.c.MyAbstractRoutingDataSource    : ===> 使用了读库1
2021-05-14 22:32:58.303  INFO 6324 --- [main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-2} inited
2021-05-14 22:32:58.324  INFO 6324 --- [main] c.z.m.m.config.ReadOnlyInterceptor       : 清除ThreadLocal
===> 读取数据
[Student{id=1, name='zhangsan'}, Student{id=2, name='lisi'}, Student{id=4, name='mazi'}]
```

查看主、从数据库数据：

```mysql
mysql> select * from student; #主库
+------+----------+
| id   | name     |
+------+----------+
|    1 | zhangsan |
|    2 | lisi     |
|    3 | wangwu   |
|    4 | mazi     |
+------+----------+

mysql> select * from student; #从库
+------+----------+
| id   | name     |
+------+----------+
|    1 | zhangsan |
|    2 | lisi     |
|    4 | mazi     |
+------+----------+
```

# 参考

* [https://juejin.cn/post/6844903858746245134](https://juejin.cn/post/6844903858746245134)
* https://www.cnblogs.com/cjsblog/p/9712457.html