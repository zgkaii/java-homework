# 作业2

**作业描述**：按自己设计的表结构，插入100万订单模拟数据，测试不同方式的插入效率。

------

订单表：

```mysql
CREATE TABLE IF NOT EXISTS `orders`
(
   `orderid`       VARCHAR(20) NOT NULL COMMENT '订单id',
   `proid`         VARCHAR(20) NOT NULL COMMENT '商品id',
   `userid`        INT NOT NULL COMMENT '用户id',
   `payment`       DECIMAL(20,2) NOT NULL COMMENT '订单金额',
   `paymenttype`   INT(1) NOT NULL COMMENT '支付类型:1-全额支付,2-分期支付',
   `postage`       DECIMAL(5,2) NOT NULL COMMENT '运费',
   `ostatus`       INT(1) NOT NULL COMMENT '订单状态:0-已取消,1-未付款,2-已付款,4-已发货,5-交易成功,6-交易关闭',
   `paymenttime`   DATETIME NOT NULL COMMENT '支付时间'
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4;

ALTER TABLE `orders` ADD PRIMARY KEY (`orderid`);
```

## 方法一：普通JDBC插入

```java
    /**
     * 普通插入
     */
    public void insert1() {
        Connection conn = null;
        PreparedStatement pstm = null;
        try {
            conn = getConnection();
            String sql = "INSERT INTO orders(orderid, proid, userid, payment, paymenttype, postage, ostatus, paymenttime) VALUES (?, ?, ?, ?, 1, ?, 2, ?);";
            pstm = conn.prepareStatement(sql);
            long startTime = System.currentTimeMillis();
            Random random = new Random();
            for (int i = 1; i <= 10000; i++) {
                pstm.setString(1, String.valueOf(i));
                pstm.setString(2, String.valueOf(random.nextInt(20)));
                pstm.setInt(3, i);
                pstm.setBigDecimal(4, BigDecimal.valueOf(2, random.nextInt(20)));
                pstm.setBigDecimal(5, BigDecimal.valueOf(2, random.nextInt(5)));
                pstm.setDate(6, java.sql.Date.valueOf(java.time.LocalDate.now()));
                pstm.executeUpdate();
            }
            long endTime = System.currentTimeMillis();
            System.out.println("Insert data success! Running time: " + (endTime - startTime));
        } catch (Exception e) {
            System.out.println("Insert data failure!");
            e.printStackTrace();
        } finally {
            releaseResources(pstm, conn);
        }
    }

	public Connection getConnection() throws ClassNotFoundException, SQLException {
        // mysql注册驱动
        Class.forName("com.mysql.cj.jdbc.Driver");
        String url = "jdbc:mysql://192.168.99.228:3307/learn";
        String username = "zgkaii";
        String password = "513701";
        // 获取连接对象
        Connection conn = DriverManager.getConnection(url, username, password);
        if (conn != null) {
            System.out.println("Database connection success!");
        }
        return conn;
    }

    private void releaseResources(PreparedStatement pstm, Connection conn) {
        // 释放资源
        if (pstm != null) {
            try {
                pstm.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
```

测试结果：

```html
Database connection success!
Insert data success! Running time: 19380
```

插入1万条数据就需要19380毫秒，平均一条数据插入时间就需要1.939豪秒！！！如果插入100万条数据大概需要30分钟！！！

## 改进一：事务

```java
    /**
     * 事务手动提交
     */
    public void insert2() {
        Connection conn = null;
        PreparedStatement pstm = null;
        try {
            conn = getConnection();
            String sql = "INSERT INTO orders(orderid, proid, userid, payment, paymenttype, postage, ostatus, paymenttime) VALUES (?, ?, ?, ?, 1, ?, 2, ?);";
            pstm = conn.prepareStatement(sql);
            conn.setAutoCommit(false);
            long startTime = System.currentTimeMillis();
            Random random = new Random();
            for (int i = 1; i <= 100000; i++) {
                pstm.setString(1, String.valueOf(i));
                pstm.setString(2, String.valueOf(random.nextInt(20)));
                pstm.setInt(3, i);
                pstm.setBigDecimal(4, BigDecimal.valueOf(2, random.nextInt(20)));
                pstm.setBigDecimal(5, BigDecimal.valueOf(2, random.nextInt(5)));
                pstm.setDate(6, java.sql.Date.valueOf(java.time.LocalDate.now()));
                pstm.executeUpdate();
            }
            conn.commit();
            long endTime = System.currentTimeMillis();
            System.out.println("Insert data success! Running time: " + (endTime - startTime));
        } catch (Exception e) {
            System.out.println("Insert data failure!");
            e.printStackTrace();
        } finally {
            releaseResources(pstm, conn);
        }
    }

```

测试结果：

```
Database connection success!
Insert data success! Running time: 18118
```

这里插入的10万条数据才18118毫秒，平均一条数据0.18毫秒，比普通JDBC插入快了近10倍，插入100万条数据大概需要3分钟！

## 改进二：批量处理

`String url`修改成`String url = "jdbc:mysql://192.168.99.228:3307/learn?rewriteBatchedStatements=true";`。

```java
    /**
     * 批量处理
     */
    public void insert3() {
        Connection conn = null;
        PreparedStatement pstm = null;
        try {
            conn = getConnection();
            String sql = "INSERT INTO orders(orderid, proid, userid, payment, paymenttype, postage, ostatus, paymenttime) VALUES (?, ?, ?, ?, 1, ?, 2, ?);";
            pstm = conn.prepareStatement(sql);
            long startTime = System.currentTimeMillis();
            Random random = new Random();
            for (int i = 1; i <= 1000000; i++) {
                pstm.setString(1, String.valueOf(i));
                pstm.setString(2, String.valueOf(random.nextInt(20)));
                pstm.setInt(3, i);
                pstm.setBigDecimal(4, BigDecimal.valueOf(2, random.nextInt(20)));
                pstm.setBigDecimal(5, BigDecimal.valueOf(2, random.nextInt(5)));
                pstm.setDate(6, java.sql.Date.valueOf(java.time.LocalDate.now()));
                pstm.addBatch();
            }
            pstm.executeBatch();
            long endTime = System.currentTimeMillis();
            System.out.println("Insert data success! Running time: " + (endTime - startTime));
        } catch (Exception e) {
            System.out.println("Insert data failure!");
            e.printStackTrace();
        } finally {
            releaseResources(pstm, conn);
        }
    }
```

测试结果：

```java
Database connection success!
Insert data success! Running time: 21310
```

这里插入的100万条数据才21310毫秒，半分钟不到就完成了！！！

## 改进三：批量处理+事务

在改进二上合上改进一即可，测试结果：

```html
Database connection success!
Insert data success! Running time: 12574
```

## 改进四：批量处理+预编译

在改进二基础上，将`String url`改成`String url = "jdbc:mysql://192.168.99.228:3307/learn?useServerPrepStmts=true&rewriteBatchedStatements=true`即可。测试结果：

```
Database connection success!
Insert data success! Running time: 31448
```

## 改进五：批量处理+预编译+事务

合并上面几种改进方法，测试结果：

```html
Database connection success!
Insert data success! Running time: 22270
```

## 对比总结

| 方法                 | 数据（条） | 时间（毫秒） | 平均耗时（毫秒/条） |
| -------------------- | ---------- | ------------ | ------------------- |
| 普通JDBC             | 1w         | 19380        | 1.938               |
| 事务                 | 10w        | 18118        | 0.181               |
| 批量处理             | 100w       | 21310        | 0.0213              |
| 批量处理+事务        | 100w       | 12574        | 0.0126              |
| 批量处理+预编译      | 100w       | 31448        | 0.0315              |
| 批量处理+预编译+事务 | 100w       | 22270        | 0.0223              |

可见，批量处理+手动提交事务对普通JDBC插入数据的效率提升最大。

> 由于以上大多只测试一次，存在一定偶然性。