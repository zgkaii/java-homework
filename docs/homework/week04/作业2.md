## 作业2

**题目描述**：思考有多少种方式，在 main 函数启动一个新线程，运行一个方法，拿到这个方法的返回值后，退出主线程? 写出所有方法。

------

### 继承Thread类创建普通线程

```java
public class ThreadTest1 {
    public static void main(String[] args) {
        System.out.println("主线程开始执行");
        // 创建自定义线程对象
        MyThreadOne mt = new MyThreadOne("子线程");
        // 启动新线程
        mt.start();
    }
}
```

```java
public class MyThreadOne extends Thread {
    public MyThreadOne(String name) {
        super(name);
    }

    @Override
    public void run() {
        Mark.mark();
        System.out.println(getName() + "正在执行");
    }
}
```

其中调用Mark.mark()方法：

```java
public class Mark {
    public static void mark() {
        System.out.println("--------Mark--------");
    }
}
```

运行结果：

```html
主线程开始执行
--------Mark--------
子线程正在执行
```

### 实现Runnable接口创建普通线程

```java
public class ThreadTest2 {
    public static void main(String[] args) {
        System.out.println("主线程开始执行");
        MyRunnable mr = new MyRunnable();
        Thread t = new Thread(mr, "子线程");
        // 启动新线程
        t.start();
    }
}
```

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        Mark.mark();
        System.out.println(Thread.currentThread().getName() + "正在执行");
    }
}
```

运行结果：

```html
主线程开始执行
--------Mark--------
子线程正在执行
```

### 匿名内部类创建普通线程

```java
public class ThreadTest3 {
    public static void main(String[] args) {
        // 1.继承Thread类
        new Thread() {
            @Override
            public void run() {
                Mark.mark();
                System.out.println(getName() + "正在执行: " + this);
            }
        }.start();
        // 2.实现Runnable接口
        new Thread(new Runnable() {
            @Override
            public void run() {
                Mark.mark();
                System.out.println(Thread.currentThread().getName() + "正在执行");
            }
        }).start();        
    }
}
```

### 创建守护线程

如果`setDaemon(true)`把该线程标记为守护线程，那么JVM在执行完main线程后就会直接退出，控制台不会有任何输出结果。

```java
public class DaemonThread {
    public static void main(String[] args) {
        Thread thread = new Thread(new DaemonRunner(), "DaemonRunner");
        thread.setDaemon(false);// 调用setDaemon(true)把该线程标记为守护线程
        thread.start();
    }

    static class DaemonRunner implements Runnable {
        @Override
        public void run() {
            Mark.mark();
            System.out.println("Thread finally run ...");
        }
    }
}
```

这里`setDaemon(false)`将线程设置成非守护线程，运行结果：

```java
--------Mark--------
Thread finally run ...
```

### 线程池创建线程

```java
public class ExecutorTest {
    public static void main(String[] args) {
        // 1.创建线程池对象
        ExecutorService poo1 = Executors.newFixedThreadPool(2);
        // 2.创建Runnable2实例对象
        MyRunnable2 mr = new MyRunnable2();
        // 3.从线程池中获取线程对象，调用MyRunnable中的run()
        poo1.submit(mr);
        // 4.再获取个线程对象，调用MyRunnable中的run()
        poo1.submit(mr);
        // 5.关闭线程池
        poo1.shutdown();
    }
}
```

```java
public class MyRunnable2 implements Runnable {
    @Override
    public void run() {
        Mark.mark();
        System.out.println("获取到线程： " + Thread.currentThread().getName());
        System.out.println(Thread.currentThread().getName() + "线程回到线程池");
    }
}
```

运行结果：

```java
--------Mark--------
--------Mark--------
获取到线程： pool-1-thread-2
pool-1-thread-2线程回到线程池
获取到线程： pool-1-thread-1
pool-1-thread-1线程回到线程池
```

### 实现Callable接口创建线程

```java
public class CallableTest {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        System.out.println("提交Callable到线程池");
        Future<Integer> future = executorService.submit(new CallableTask());
        try {
            long startTime = System.currentTimeMillis();
            System.out.println("主线程等待获取Future结果");
            while (!future.isDone()) {
                System.out.println("子线程还未执行完");
                Thread.sleep(1000);
            }
            if (!future.isCancelled()) {
                System.out.println("子线程任务已完成");
                System.out.println("主线程获取到 Future 结果: " + future.get());
            } else {
                System.out.println("子线程任务被取消");
            }
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }


    static class CallableTask implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            System.out.println("子线程开始");
            Mark.mark();
            Thread.sleep(2000);
            return new Random().nextInt();
        }
    }
}
```

运行结果：

```java
提交Callable到线程池
主线程等待获取Future结果
子线程还未执行完
子线程开始
--------Mark--------
子线程还未执行完
子线程任务已完成
主线程获取到 Future 结果: -1467954793
```

